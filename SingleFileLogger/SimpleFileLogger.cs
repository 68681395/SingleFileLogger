//===============================================================================

#region Using

// Simple File Logger Not Simple Function,Entirely Independent
//===============================================================================
//This is an open source from Microsoft patterns & practices Enterprise Library Logging Application Block
//We have done lots of enhancement,
//===============================================================================

#endregion

namespace Tsharp
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Data;
    using System.IO;
    using System.Linq;
    using System.Runtime.Versioning;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using static SimpleFileLogger;

    public class SimpleFileLogger
    {
        /// <summary>
        ///     Defines the behavior when the roll file is created.
        /// </summary>
        public enum RollFileExistsBehavior
        {
            /// <summary>
            ///     Overwrites the file if it already exists.
            /// </summary>
            Overwrite,

            /// <summary>
            ///     Use a secuence number at the end of the generated file if it already exists. If it fails again then increment the
            ///     secuence until a non existent filename is found.
            /// </summary>
            Increment
        }

        /// <summary>
        ///     Defines the frequency when the file need to be rolled.
        /// </summary>
        public enum RollInterval
        {
            /// <summary>
            ///     None Interval
            /// </summary>
            None,

            /// <summary>
            ///     Minute Interval
            /// </summary>
            Minute,

            /// <summary>
            ///     Hour interval
            /// </summary>
            Hour,

            /// <summary>
            ///     Day Interval
            /// </summary>
            Day,

            /// <summary>
            ///     Week Interval
            /// </summary>
            Week,

            /// <summary>
            ///     Month Interval
            /// </summary>
            Month,

            /// <summary>
            ///     Year Interval
            /// </summary>
            Year,

            /// <summary>
            ///     At Midnight
            /// </summary>
            Midnight
        }

        /// <summary>
        ///     Purges archive files generated by the <see cref="RollingFlatFileTraceListener" />.
        /// </summary>
        public class RollingFlatFilePurger
        {
            private readonly string baseFileName;

            private readonly int cap;

            private readonly string directory;

            /// <summary>
            ///     Initializes a new instance of the <see cref="RollingFlatFilePurger" /> class.
            /// </summary>
            /// <param name="directory">The folder where archive files are kept.</param>
            /// <param name="baseFileName">The base name for archive files.</param>
            /// <param name="cap">The number of archive files to keep.</param>
            public RollingFlatFilePurger(string directory, string baseFileName, int cap)
            {
                if (directory == null) throw new ArgumentNullException("directory");
                if (baseFileName == null) throw new ArgumentNullException("baseFileName");
                if (cap < 1) throw new ArgumentOutOfRangeException("cap");

                this.directory = directory;
                this.baseFileName = baseFileName;
                this.cap = cap;
            }

            /// <summary>
            ///     Purges archive files.
            /// </summary>
            public void Purge()
            {
                var extension = Path.GetExtension(this.baseFileName);
                var searchPattern = Path.GetFileNameWithoutExtension(this.baseFileName) + ".*" + extension;

                var matchingFiles = this.TryGetMatchingFiles(searchPattern);

                if (matchingFiles.Length <= this.cap) return;

                // sort the archive files in descending order by creation date and sequence number
                var sortedArchiveFiles =
                    matchingFiles.Select(matchingFile => new ArchiveFile(matchingFile))
                        .OrderByDescending(archiveFile => archiveFile);

                using (var enumerator = sortedArchiveFiles.GetEnumerator())
                {
                    // skip the most recent files
                    for (var i = 0; i < this.cap; i++) if (!enumerator.MoveNext()) return;

                    // delete the older files
                    while (enumerator.MoveNext()) TryDelete(enumerator.Current.Path);
                }
            }

            private string[] TryGetMatchingFiles(string searchPattern)
            {
                try
                {
                    return Directory.GetFiles(this.directory, searchPattern, SearchOption.TopDirectoryOnly);
                }
                catch (DirectoryNotFoundException)
                {
                }
                catch (IOException)
                {
                }
                catch (UnauthorizedAccessException)
                {
                }

                return new string[0];
            }

            private static void TryDelete(string path)
            {
                try
                {
                    File.Delete(path);
                }
                catch (UnauthorizedAccessException)
                {
                    // cannot delete the file because of a permissions issue - just skip it
                }
                catch (IOException)
                {
                    // cannot delete the file, most likely because it is already opened - just skip it
                }
            }

            private static DateTime GetCreationTime(string path)
            {
                try
                {
                    return File.GetCreationTimeUtc(path);
                }
                catch (UnauthorizedAccessException)
                {
                    // will cause file be among the first files when sorting, 
                    // and its deletion will likely fail causing it to be skipped
                    return DateTime.MinValue;
                }
            }

            /// <summary>
            ///     Extracts the sequence number from an archive file name.
            /// </summary>
            /// <param name="fileName">The archive file name.</param>
            /// <returns>The sequence part of the file name.</returns>
            public static string GetSequence(string fileName)
            {
                if (fileName == null) throw new ArgumentNullException(fileName, "fileName");

                var extensionDotIndex = fileName.LastIndexOf('.');
                if (extensionDotIndex <= 0) return string.Empty;
                var sequenceDotIndex = fileName.LastIndexOf('.', extensionDotIndex - 1);
                if (sequenceDotIndex < 0) return string.Empty;

                return fileName.Substring(sequenceDotIndex + 1, extensionDotIndex - sequenceDotIndex - 1);
            }

            internal class ArchiveFile : IComparable<ArchiveFile>
            {
                private readonly string fileName;

                private int? sequence;

                private string sequenceString;

                public ArchiveFile(string path)
                {
                    this.Path = path;
                    this.fileName = System.IO.Path.GetFileName(path);
                    this.CreationTime = GetCreationTime(path);
                }

                public string Path { get; }

                public DateTime CreationTime { get; }

                public string SequenceString
                {
                    get
                    {
                        if (this.sequenceString == null) this.sequenceString = GetSequence(this.fileName);

                        return this.sequenceString;
                    }
                }

                public int Sequence
                {
                    get
                    {
                        if (!this.sequence.HasValue)
                        {
                            int theSequence;
                            if (int.TryParse(
                                this.SequenceString,
                                NumberStyles.None,
                                CultureInfo.InvariantCulture,
                                out theSequence)) this.sequence = theSequence;
                            else this.sequence = 0;
                        }

                        return this.sequence.Value;
                    }
                }

                public int CompareTo(ArchiveFile other)
                {
                    var creationDateComparison = this.CreationTime.CompareTo(other.CreationTime);
                    if (creationDateComparison != 0) return creationDateComparison;

                    if ((this.Sequence != 0) && (other.Sequence != 0)) return this.Sequence.CompareTo(other.Sequence);
                    // compare the sequence part of the file name as plain strings
                    return this.SequenceString.CompareTo(other.SequenceString);
                }
            }
        }

        /// <summary>
        ///     Helper class for working with environment variables.
        /// </summary>
        public class EnvironmentHelper
        {
            /// <summary>
            ///     Sustitute the Environment Variables
            /// </summary>
            /// <param name="fileName">The filename.</param>
            /// <returns></returns>
            public static string ReplaceEnvironmentVariables(string fileName)
            {
                // Check EnvironmentPermission for the ability to access the environment variables.
                try
                {
                    var variables = Environment.ExpandEnvironmentVariables(fileName);

                    // If an Environment Variable is not found then remove any invalid tokens
                    var filter = new Regex("%(.*?)%", RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);

                    var filePath = filter.Replace(variables, "");

                    if (Path.GetDirectoryName(filePath) == null) filePath = Path.GetFileName(filePath);

                    return RootFileNameAndEnsureTargetFolderExists(filePath);
                }
                catch (SecurityException)
                {
                    throw new InvalidOperationException("Environment Variables access denied.");
                }
            }

            private static string RootFileNameAndEnsureTargetFolderExists(string fileName)
            {
                var rootedFileName = fileName;
                if (!Path.IsPathRooted(rootedFileName))
                    rootedFileName = Path.Combine(
                        AppDomain.CurrentDomain.SetupInformation.ApplicationBase,
                        rootedFileName);

                var directory = Path.GetDirectoryName(rootedFileName);
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory)) Directory.CreateDirectory(directory);

                return rootedFileName;
            }
        }

        /// <devdoc>
        ///     <para>
        ///         Provides the <see langword='abstract ' />base class for the listeners who
        ///         monitor trace and debug output.
        ///     </para>
        /// </devdoc>
        [HostProtection(Synchronization = true)]
        public abstract class TraceListener : IDisposable
        {
            private int indentLevel;

            private int indentSize = 4;

            private string listenerName;

            /// <devdoc>
            ///     <para>Initializes a new instance of the <see cref='System.Diagnostics.TraceListener' /> class.</para>
            /// </devdoc>
            protected TraceListener()
            {
            }

            /// <devdoc>
            ///     <para>
            ///         Initializes a new instance of the <see cref='System.Diagnostics.TraceListener' /> class using the specified
            ///         name as the
            ///         listener.
            ///     </para>
            /// </devdoc>
            protected TraceListener(string name)
            {
                this.listenerName = name;
            }

            /// <devdoc>
            ///     <para> Gets or sets a name for this <see cref='System.Diagnostics.TraceListener' />.</para>
            /// </devdoc>
            public virtual string Name
            {
                get
                {
                    return this.listenerName == null ? "" : this.listenerName;
                }

                set
                {
                    this.listenerName = value;
                }
            }

            public virtual bool IsThreadSafe
            {
                get
                {
                    return false;
                }
            }

            /// <devdoc>
            ///     <para>Gets or sets the indent level.</para>
            /// </devdoc>
            public int IndentLevel
            {
                get
                {
                    return this.indentLevel;
                }

                set
                {
                    this.indentLevel = value < 0 ? 0 : value;
                }
            }

            /// <devdoc>
            ///     <para>Gets or sets the number of spaces in an indent.</para>
            /// </devdoc>
            public int IndentSize
            {
                get
                {
                    return this.indentSize;
                }

                set
                {
                    if (value < 0)
                        throw new ArgumentOutOfRangeException(
                                  "IndentSize",
                                  value,
                                  "IndentSize must be greater then zero");
                    this.indentSize = value;
                }
            }

            /// <devdoc>
            ///     <para>Gets or sets a value indicating whether an indent is needed.</para>
            /// </devdoc>
            protected bool NeedIndent { get; set; } = true;

            /// <devdoc>
            /// </devdoc>
            public void Dispose()
            {
                this.Dispose(true);
                GC.SuppressFinalize(this);
            }

            /// <devdoc>
            /// </devdoc>
            protected virtual void Dispose(bool disposing)
            {
            }

            /// <devdoc>
            ///     <para>
            ///         When overridden in a derived class, closes the output stream
            ///         so that it no longer receives tracing or debugging output.
            ///     </para>
            /// </devdoc>
            public virtual void Close()
            {
            }

            /// <devdoc>
            ///     <para>When overridden in a derived class, flushes the output buffer.</para>
            /// </devdoc>
            public virtual void Flush()
            {
            }

            /// <devdoc>
            ///     <para>
            ///         When overridden in a derived class, writes the specified
            ///         message to the listener you specify in the derived class.
            ///     </para>
            /// </devdoc>
            public abstract void Write(string message);

            /// <devdoc>
            ///     <para>
            ///         Writes the name of the <paramref name="o" /> parameter to the listener you specify when you inherit from the
            ///         <see cref='System.Diagnostics.TraceListener' />
            ///         class.
            ///     </para>
            /// </devdoc>
            public virtual void Write(object o)
            {
                if (o == null) return;
                this.Write(o.ToString());
            }

            /// <devdoc>
            ///     <para>
            ///         Writes a category name and a message to the listener you specify when you
            ///         inherit from the <see cref='System.Diagnostics.TraceListener' />
            ///         class.
            ///     </para>
            /// </devdoc>
            public virtual void Write(string message, string category)
            {
                if (category == null) this.Write(message);
                else this.Write(category + ": " + (message == null ? string.Empty : message));
            }

            /// <devdoc>
            ///     <para>
            ///         Writes a category name and the name of the <paramref name="o" /> parameter to the listener you
            ///         specify when you inherit from the <see cref='System.Diagnostics.TraceListener' />
            ///         class.
            ///     </para>
            /// </devdoc>
            public virtual void Write(object o, string category)
            {
                if (category == null) this.Write(o);
                else this.Write(o == null ? "" : o.ToString(), category);
            }

            /// <devdoc>
            ///     <para>
            ///         Writes the indent to the listener you specify when you
            ///         inherit from the <see cref='System.Diagnostics.TraceListener' />
            ///         class, and resets the <see cref='TraceListener.NeedIndent' /> property to <see langword='false' />.
            ///     </para>
            /// </devdoc>
            protected virtual void WriteIndent()
            {
                this.NeedIndent = false;
                for (var i = 0; i < this.indentLevel; i++)
                    if (this.indentSize == 4) this.Write("    ");
                    else for (var j = 0; j < this.indentSize; j++) this.Write(" ");
            }

            /// <devdoc>
            ///     <para>
            ///         When overridden in a derived class, writes a message to the listener you specify in
            ///         the derived class, followed by a line terminator. The default line terminator is a carriage return followed
            ///         by a line feed (\r\n).
            ///     </para>
            /// </devdoc>
            public abstract void WriteLine(string message);

            /// <devdoc>
            ///     <para>
            ///         Writes the name of the <paramref name="o" /> parameter to the listener you specify when you inherit from the
            ///         <see cref='System.Diagnostics.TraceListener' /> class, followed by a line terminator. The default line
            ///         terminator is a
            ///         carriage return followed by a line feed
            ///         (\r\n).
            ///     </para>
            /// </devdoc>
            public virtual void WriteLine(object o)
            {
                this.WriteLine(o == null ? "" : o.ToString());
            }

            /// <devdoc>
            ///     <para>
            ///         Writes a category name and a message to the listener you specify when you
            ///         inherit from the <see cref='System.Diagnostics.TraceListener' /> class,
            ///         followed by a line terminator. The default line terminator is a carriage return followed by a line feed (\r\n).
            ///     </para>
            /// </devdoc>
            public virtual void WriteLine(string message, string category)
            {
                if (category == null) this.WriteLine(message);
                else this.WriteLine(category + ": " + (message == null ? string.Empty : message));
            }

            /// <devdoc>
            ///     <para>
            ///         Writes a category
            ///         name and the name of the <paramref name="o" />parameter to the listener you
            ///         specify when you inherit from the <see cref='System.Diagnostics.TraceListener' />
            ///         class, followed by a line terminator. The default line terminator is a carriage
            ///         return followed by a line feed (\r\n).
            ///     </para>
            /// </devdoc>
            public virtual void WriteLine(object o, string category)
            {
                this.WriteLine(o == null ? "" : o.ToString(), category);
            }
        }

        /// <devdoc>
        ///     <para>
        ///         Directs tracing or debugging output to
        ///         a <see cref='T:System.IO.TextWriter' /> or to a <see cref='T:System.IO.Stream' />,
        ///         such as <see cref='F:System.Console.Out' /> or <see cref='T:System.IO.FileStream' />.
        ///     </para>
        /// </devdoc>
        [HostProtection(Synchronization = true)]
        public class TextWriterTraceListener : TraceListener
        {
            private readonly string _carriageReturnAndLineFeedReplacement = ",";

            private readonly bool _replaceCarriageReturnsAndLineFeedsFromFieldValues = true;

            private string fileName;

            internal TextWriter writer;

            /// <devdoc>
            ///     <para>
            ///         Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener' /> class with
            ///         <see cref='System.IO.TextWriter' />
            ///         as the output recipient.
            ///     </para>
            /// </devdoc>
            public TextWriterTraceListener()
            {
            }

            /// <devdoc>
            ///     <para>
            ///         Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener' /> class, using the
            ///         stream as the recipient of the debugging and tracing output.
            ///     </para>
            /// </devdoc>
            public TextWriterTraceListener(Stream stream)
                : this(stream, string.Empty)
            {
            }

            /// <devdoc>
            ///     <para>
            ///         Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener' /> class with the
            ///         specified name and using the stream as the recipient of the debugging and tracing output.
            ///     </para>
            /// </devdoc>
            public TextWriterTraceListener(Stream stream, string name)
                : base(name)
            {
                if (stream == null) throw new ArgumentNullException("stream");
                this.writer = new StreamWriter(stream);
            }

            /// <devdoc>
            ///     <para>
            ///         Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener' /> class using the
            ///         specified writer as recipient of the tracing or debugging output.
            ///     </para>
            /// </devdoc>
            public TextWriterTraceListener(TextWriter writer)
                : this(writer, string.Empty)
            {
            }

            /// <devdoc>
            ///     <para>
            ///         Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener' /> class with the
            ///         specified name and using the specified writer as recipient of the tracing or
            ///         debugging
            ///         output.
            ///     </para>
            /// </devdoc>
            public TextWriterTraceListener(TextWriter writer, string name)
                : base(name)
            {
                if (writer == null) throw new ArgumentNullException("writer");
                this.writer = writer;
            }

            /// <devdoc>
            ///     <para>[To be supplied.]</para>
            /// </devdoc>
            [ResourceExposure(ResourceScope.Machine)]
            public TextWriterTraceListener(string fileName)
            {
                this.fileName = fileName;
            }

            /// <devdoc>
            ///     <para>[To be supplied.]</para>
            /// </devdoc>
            [ResourceExposure(ResourceScope.Machine)]
            public TextWriterTraceListener(string fileName, string name)
                : base(name)
            {
                this.fileName = fileName;
            }

            /// <devdoc>
            ///     <para>
            ///         Indicates the text writer that receives the tracing
            ///         or debugging output.
            ///     </para>
            /// </devdoc>
            public TextWriter Writer
            {
                get
                {
                    this.EnsureWriter();
                    return this.writer;
                }

                set
                {
                    this.writer = value;
                }
            }

            /// <devdoc>
            ///     <para>
            ///         Closes the <see cref='System.Diagnostics.TextWriterTraceListener.Writer' /> so that it no longer
            ///         receives tracing or debugging output.
            ///     </para>
            /// </devdoc>
            public override void Close()
            {
                if (this.writer != null)
                    try
                    {
                        this.writer.Close();
                    }
                    catch (ObjectDisposedException)
                    {
                    }

                this.writer = null;
            }

            /// <internalonly />
            /// <devdoc>
            /// </devdoc>
            protected override void Dispose(bool disposing)
            {
                try
                {
                    if (disposing)
                    {
                        this.Close();
                    }
                    else
                    {
                        // clean up resources
                        if (this.writer != null)
                            try
                            {
                                this.writer.Close();
                            }
                            catch (ObjectDisposedException)
                            {
                            }
                        this.writer = null;
                    }
                }
                finally
                {
                    base.Dispose(disposing);
                }
            }

            /// <devdoc>
            ///     <para>Flushes the output buffer for the <see cref='System.Diagnostics.TextWriterTraceListener.Writer' />.</para>
            /// </devdoc>
            public override void Flush()
            {
                if (!this.EnsureWriter()) return;
                try
                {
                    this.writer.Flush();
                }
                catch (ObjectDisposedException)
                {
                }
            }

            /// <devdoc>
            ///     <para>
            ///         Writes a message
            ///         to this instance's <see cref='System.Diagnostics.TextWriterTraceListener.Writer' />.
            ///     </para>
            /// </devdoc>
            public override void Write(string message)
            {
                if (!this.EnsureWriter()) return;
                if (this.NeedIndent) this.WriteIndent();
                try
                {
                    this.writer.Write(message);
                }
                catch (ObjectDisposedException)
                {
                }
            }

            /// <devdoc>
            ///     <para>
            ///         Writes a message
            ///         to this instance's <see cref='System.Diagnostics.TextWriterTraceListener.Writer' /> followed by a line
            ///         terminator. The
            ///         default line terminator is a carriage return followed by a line feed (\r\n).
            ///     </para>
            /// </devdoc>
            public override void WriteLine(string message)
            {
                if (!this.EnsureWriter()) return;
                if (this.NeedIndent) this.WriteIndent();
                try
                {
                    this.writer.WriteLine(message);
                    this.NeedIndent = true;
                }
                catch (ObjectDisposedException)
                {
                }
            }

            public virtual void WriteCsvLine(params string[] fields)
            {
                if (!this.EnsureWriter()) return;
                if (this.NeedIndent) this.WriteIndent();
                try
                {
                    this.WriteRecord(this.writer, fields);
                }
                catch (ObjectDisposedException)
                {
                }
            }

            private void WriteRecord(TextWriter writer, params string[] fields)
            {
                if (null == fields) return;
                for (var i = 0; i < fields.Length; i++)
                {
                    var quotesRequired = fields[i].Contains(",");
                    var escapeQuotes = fields[i].Contains("\"");
                    var fieldValue = escapeQuotes ? fields[i].Replace("\"", "\"\"") : fields[i];

                    if (this._replaceCarriageReturnsAndLineFeedsFromFieldValues
                        && (fieldValue.Contains("\r") || fieldValue.Contains("\n")))
                    {
                        quotesRequired = true;
                        fieldValue = fieldValue.Replace("\r\n", this._carriageReturnAndLineFeedReplacement);
                        fieldValue = fieldValue.Replace("\r", this._carriageReturnAndLineFeedReplacement);
                        fieldValue = fieldValue.Replace("\n", this._carriageReturnAndLineFeedReplacement);
                    }

                    writer.Write(
                        "{0}{1}{0}{2}",
                        quotesRequired || escapeQuotes ? "\"" : string.Empty,
                        fieldValue,
                        i < fields.Length - 1 ? "," : string.Empty);
                }
                writer.WriteLine();
            }

            private static Encoding GetEncodingWithFallback(Encoding encoding)
            {
                // Clone it and set the "?" replacement fallback
                var fallbackEncoding = (Encoding)encoding.Clone();
                fallbackEncoding.EncoderFallback = EncoderFallback.ReplacementFallback;
                fallbackEncoding.DecoderFallback = DecoderFallback.ReplacementFallback;

                return fallbackEncoding;
            }

            // This uses a machine resource, scoped by the fileName variable. 
            [ResourceExposure(ResourceScope.None)]
            [ResourceConsumption(ResourceScope.Machine, ResourceScope.Machine)]
            internal bool EnsureWriter()
            {
                var ret = true;

                if (this.writer == null)
                {
                    ret = false;

                    if (this.fileName == null) return ret;

                    // StreamWriter by default uses UTF8Encoding which will throw on invalid encoding errors.
                    // This can cause the internal StreamWriter's state to be irrecoverable. It is bad for tracing
                    // APIs to throw on encoding errors. Instead, we should provide a "?" replacement fallback
                    // encoding to substitute illegal chars. For ex, In case of high surrogate character 
                    // D800-DBFF without a following low surrogate character DC00-DFFF
                    // NOTE: We also need to use an encoding that does't emit BOM whic is StreamWriter's default 
                    var noBOMwithFallback = GetEncodingWithFallback(new UTF8Encoding(false));

                    // To support multiple appdomains/instances tracing to the same file,
                    // we will try to open the given file for append but if we encounter
                    // IO errors, we will prefix the file name with a unique GUID value
                    // and try one more time 
                    var fullPath = Path.GetFullPath(this.fileName);
                    var dirPath = Path.GetDirectoryName(fullPath);
                    var fileNameOnly = Path.GetFileName(fullPath);

                    for (var i = 0; i < 2; i++)
                        try
                        {
                            this.writer = new StreamWriter(fullPath, true, noBOMwithFallback, 4096);
                            ret = true;
                            break;
                        }
                        catch (IOException)
                        {
                            // Should we do this only for ERROR_SHARING_VIOLATION?
                            //if (InternalResources.MakeErrorCodeFromHR(Marshal.GetHRForException(ioexc)) == InternalResources.ERROR_SHARING_VIOLATION) { 

                            fileNameOnly = Guid.NewGuid() + fileNameOnly;
                            fullPath = Path.Combine(dirPath, fileNameOnly);
                        }
                        catch (UnauthorizedAccessException)
                        {
                            //ERROR_ACCESS_DENIED, mostly ACL issues 
                            break;
                        }
                        catch (Exception)
                        {
                            break;
                        }

                    if (!ret) this.fileName = null;
                }
                return ret;
            }
        }

        /// <summary>
        ///     Extends <see cref="TextWriterTraceListener" /> to add formatting capabilities.
        /// </summary>
        public class FormattedTextWriterTraceListener : TextWriterTraceListener
        {
            /// <summary>
            ///     Initializes a new instance of <see cref="FormattedTextWriterTraceListener" />.
            /// </summary>
            public FormattedTextWriterTraceListener()
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="FormattedTextWriterTraceListener" /> with a <see cref="Stream" />.
            /// </summary>
            /// <param name="stream">The stream to write to.</param>
            public FormattedTextWriterTraceListener(Stream stream)
                : base(stream)
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="FormattedTextWriterTraceListener" /> with a <see cref="TextWriter" />.
            /// </summary>
            /// <param name="writer">The writer to write to.</param>
            public FormattedTextWriterTraceListener(TextWriter writer)
                : base(writer)
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="FormattedTextWriterTraceListener" /> with a file name.
            /// </summary>
            /// <param name="fileName">The file name to write to.</param>
            public FormattedTextWriterTraceListener(string fileName)
                : base(EnvironmentHelper.ReplaceEnvironmentVariables(fileName))
            {
            }

            /// <summary>
            ///     Initializes a new named instance of <see cref="FormattedTextWriterTraceListener" /> with a <see cref="Stream" />.
            /// </summary>
            /// <param name="stream">The stream to write to.</param>
            /// <param name="name">The name.</param>
            public FormattedTextWriterTraceListener(Stream stream, string name)
                : base(stream, name)
            {
            }

            /// <summary>
            ///     Initializes a new named instance of <see cref="FormattedTextWriterTraceListener" /> with a
            ///     <see cref="TextWriter" />.
            /// </summary>
            /// <param name="writer">The writer to write to.</param>
            /// <param name="name">The name.</param>
            public FormattedTextWriterTraceListener(TextWriter writer, string name)
                : base(writer, name)
            {
            }

            /// <summary>
            ///     Initializes a new named instance of <see cref="FormattedTextWriterTraceListener" /> with a
            ///     <see cref="ILogFormatter" /> and a file name.
            /// </summary>
            /// <param name="fileName">The file name to write to.</param>
            /// <param name="name">The name.</param>
            public FormattedTextWriterTraceListener(string fileName, string name)
                : base(EnvironmentHelper.ReplaceEnvironmentVariables(fileName), name)
            {
            }

            public sealed override void Write(object o)
            {
                base.Write(o);
            }
        }

        /// <summary>
        ///     A <see cref="TraceListener" /> that writes to a flat file, formatting the output with an
        ///     <see cref="ILogFormatter" />.
        /// </summary>
        public class FlatFileTraceListener : FormattedTextWriterTraceListener
        {
            private readonly string footer = string.Empty;

            private readonly string header = string.Empty;

            /// <summary>
            ///     Initializes a new instance of <see cref="FlatFileTraceListener" />.
            /// </summary>
            public FlatFileTraceListener()
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="FlatFileTraceListener" /> with a <see cref="FileStream" />.
            /// </summary>
            /// <param name="stream">The file stream.</param>
            public FlatFileTraceListener(FileStream stream)
                : base(stream)
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="FlatFileTraceListener" /> with a <see cref="StreamWriter" />.
            /// </summary>
            /// <param name="writer">The stream writer.</param>
            public FlatFileTraceListener(StreamWriter writer)
                : base(writer)
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="FlatFileTraceListener" /> with a file name.
            /// </summary>
            /// <param name="fileName">The file name.</param>
            public FlatFileTraceListener(string fileName)
                : base(fileName)
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="FlatFileTraceListener" /> with a file name, a header, and a footer.
            /// </summary>
            /// <param name="fileName">The file stream.</param>
            /// <param name="header">The header.</param>
            /// <param name="footer">The footer.</param>
            public FlatFileTraceListener(string fileName, string header, string footer)
                : base(fileName)
            {
                this.header = header;
                this.footer = footer;
            }

            /// <summary>
            ///     Initializes a new name instance of <see cref="FlatFileTraceListener" /> with a <see cref="FileStream" />.
            /// </summary>
            /// <param name="stream">The file stream.</param>
            /// <param name="name">The name.</param>
            public FlatFileTraceListener(FileStream stream, string name)
                : base(stream, name)
            {
            }

            /// <summary>
            ///     Initializes a new named instance of <see cref="FlatFileTraceListener" /> with a <see cref="StreamWriter" />.
            /// </summary>
            /// <param name="writer">The stream writer.</param>
            /// <param name="name">The name.</param>
            public FlatFileTraceListener(StreamWriter writer, string name)
                : base(writer, name)
            {
            }

            /// <summary>
            ///     Initializes a new named instance of <see cref="FlatFileTraceListener" /> with a file name.
            /// </summary>
            /// <param name="fileName">The file name.</param>
            /// <param name="name">The name.</param>
            public FlatFileTraceListener(string fileName, string name)
                : base(fileName, name)
            {
            }

            public override void WriteLine(string message)
            {
                if (!string.IsNullOrEmpty(this.header)) base.WriteLine(this.header);
                base.WriteLine(message);
                if (!string.IsNullOrEmpty(this.footer)) base.WriteLine(this.footer);
            }
        }

        /// <summary>
        ///     Performs logging to a file and rolls the output file when either time or size thresholds are
        ///     exceeded.
        /// </summary>
        /// <remarks>
        ///     Logging always occurs to the configured file name, and when roll occurs a new rolled file name is calculated
        ///     by adding the timestamp pattern to the configured file name.
        ///     <para />
        ///     The need of rolling is calculated before performing a logging operation, so even if the thresholds are exceeded
        ///     roll will not occur until a new entry is logged.
        ///     <para />
        ///     Both time and size thresholds can be configured, and when the first of them occurs both will be reset.
        ///     <para />
        ///     The elapsed time is calculated from the creation date of the logging file.
        /// </remarks>
        public class RollingFlatFileTraceListener : FlatFileTraceListener
        {
            private readonly string archivedFolderPattern;

            private readonly int maxArchivedFiles;

            private readonly RollFileExistsBehavior rollFileExistsBehavior;

            private readonly RollInterval rollInterval;

            private readonly int rollSizeInBytes;

            private readonly string timeStampPattern;

            /// <summary>
            ///     Initializes a new instance of <see cref="RollingFlatFileTraceListener" />
            /// </summary>
            /// <param name="fileName">The filename where the entries will be logged.</param>
            /// <param name="header">The header to add before logging an entry.</param>
            /// <param name="footer">The footer to add after logging an entry.</param>
            /// <param name="formatter">The formatter.</param>
            /// <param name="rollSizeKB">The maxium file size (KB) before rolling.</param>
            /// <param name="timeStampPattern">The date format that will be appended to the new roll file.</param>
            /// <param name="archivedFolderPattern">The archived folder pattern.</param>
            /// <param name="rollFileExistsBehavior">Expected behavior that will be used when the roll file has to be created.</param>
            /// <param name="rollInterval">The time interval that makes the file rolles.</param>
            public RollingFlatFileTraceListener(
                string fileName,
                string header,
                string footer,
                int rollSizeKB,
                string timeStampPattern,
                string archivedFolderPattern,
                RollFileExistsBehavior rollFileExistsBehavior,
                RollInterval rollInterval)
                : this(
                    fileName,
                    header,
                    footer,
                    rollSizeKB,
                    timeStampPattern,
                    archivedFolderPattern,
                    rollFileExistsBehavior,
                    rollInterval,
                    0)
            {
            }

            /// <summary>
            ///     Initializes a new instance of <see cref="RollingFlatFileTraceListener" />
            /// </summary>
            /// <param name="fileName">The filename where the entries will be logged.</param>
            /// <param name="header">The header to add before logging an entry.</param>
            /// <param name="footer">The footer to add after logging an entry.</param>
            /// <param name="formatter">The formatter.</param>
            /// <param name="rollSizeKB">The maxium file size (KB) before rolling.</param>
            /// <param name="timeStampPattern">The date format that will be appended to the new roll file.</param>
            /// <param name="archivedFolderPattern">The archived folder pattern.</param>
            /// <param name="rollFileExistsBehavior">Expected behavior that will be used when the roll file has to be created.</param>
            /// <param name="rollInterval">The time interval that makes the file rolles.</param>
            /// <param name="maxArchivedFiles">The maximum number of archived files to keep.</param>
            public RollingFlatFileTraceListener(
                string fileName,
                string header,
                string footer,
                int rollSizeKB,
                string timeStampPattern,
                string archivedFolderPattern,
                RollFileExistsBehavior rollFileExistsBehavior,
                RollInterval rollInterval,
                int maxArchivedFiles)
                : base(fileName, header, footer)
            {
                this.archivedFolderPattern = archivedFolderPattern;
                this.rollSizeInBytes = rollSizeKB * 1024;
                this.timeStampPattern = timeStampPattern;
                this.rollFileExistsBehavior = rollFileExistsBehavior;
                this.rollInterval = rollInterval;
                this.maxArchivedFiles = maxArchivedFiles;

                this.RollingHelper = new StreamWriterRollingHelper(this);
            }

            /// <summary>
            ///     Gets the <see cref="StreamWriterRollingHelper" /> for the flat file.
            /// </summary>
            /// <value>
            ///     The <see cref="StreamWriterRollingHelper" /> for the flat file.
            /// </value>
            public StreamWriterRollingHelper RollingHelper { get; }

            public override void WriteLine(object o)
            {
                this.RollingHelper.RollIfNecessary();
                base.WriteLine(o);
            }

            public override void Write(string message)
            {
                this.RollingHelper.RollIfNecessary();
                base.Write(message);
            }

            public override void WriteCsvLine(params string[] fields)
            {
                this.RollingHelper.RollIfNecessary();
                base.WriteCsvLine(fields);
            }

            /// <summary>
            ///     A data time provider.
            /// </summary>
            public class DateTimeProvider
            {
                /// <summary>
                ///     Gets the current data time.
                /// </summary>
                /// <value>
                ///     The current data time.
                /// </value>
                public virtual DateTime CurrentDateTime
                {
                    get
                    {
                        return DateTime.Now;
                    }
                }
            }

            /// <summary>
            ///     Encapsulates the logic to perform rolls.
            /// </summary>
            /// <remarks>
            ///     If no rolling behavior has been configured no further processing will be performed.
            /// </remarks>
            public sealed class StreamWriterRollingHelper
            {
                /// <summary>
                ///     The trace listener for which rolling is being managed.
                /// </summary>
                private readonly RollingFlatFileTraceListener owner;

                /// <summary>
                ///     A flag indicating whether at least one rolling criteria has been configured.
                /// </summary>
                private readonly bool performsRolling;

                private DateTimeProvider dateTimeProvider;

                /// <summary>
                ///     A tally keeping writer used when file size rolling is configured.
                ///     <para />
                ///     The original stream writer from the base trace listener will be replaced with
                ///     this listener.
                /// </summary>
                private TallyKeepingFileStreamWriter managedWriter;

                /// <summary>
                ///     Initialize a new instance of the <see cref="StreamWriterRollingHelper" /> class with a
                ///     <see cref="RollingFlatFileTraceListener" />.
                /// </summary>
                /// <param name="owner">The <see cref="RollingFlatFileTraceListener" /> to use.</param>
                public StreamWriterRollingHelper(RollingFlatFileTraceListener owner)
                {
                    this.owner = owner;
                    this.dateTimeProvider = new DateTimeProvider();

                    this.performsRolling = (this.owner.rollInterval != RollInterval.None)
                                           || (this.owner.rollSizeInBytes > 0);
                }

                /// <summary>
                ///     Gets the provider for the current date. Necessary for unit testing.
                /// </summary>
                /// <value>
                ///     The provider for the current date. Necessary for unit testing.
                /// </value>
                public DateTimeProvider DateTimeProvider
                {
                    set
                    {
                        this.dateTimeProvider = value;
                    }
                }

                /// <summary>
                ///     Gets the next date when date based rolling should occur if configured.
                /// </summary>
                /// <value>
                ///     The next date when date based rolling should occur if configured.
                /// </value>
                public DateTime? NextRollDateTime { get; private set; }

                /// <summary>
                ///     Calculates the next roll date for the file.
                /// </summary>
                /// <param name="dateTime">The new date.</param>
                /// <returns>The new date time to use.</returns>
                public DateTime CalculateNextRollDate(DateTime dateTime)
                {
                    switch (this.owner.rollInterval)
                    {
                        case RollInterval.Minute:
                            return dateTime.AddMinutes(1);
                        case RollInterval.Hour:
                            return dateTime.AddHours(1);
                        case RollInterval.Day:
                            return dateTime.AddDays(1);
                        case RollInterval.Week:
                            return dateTime.AddDays(7);
                        case RollInterval.Month:
                            return dateTime.AddMonths(1);
                        case RollInterval.Year:
                            return dateTime.AddYears(1);
                        case RollInterval.Midnight:
                            return dateTime.AddDays(1).Date;
                        default:
                            return DateTime.MaxValue;
                    }
                }

                /// <summary>
                ///     Checks whether rolling should be performed, and returns the date to use when performing the roll.
                /// </summary>
                /// <returns>The date roll to use if performing a roll, or <see langword="null" /> if no rolling should occur.</returns>
                /// <remarks>
                ///     Defer request for the roll date until it is necessary to avoid overhead.
                ///     <para />
                ///     Information used for rolling checks should be set by now.
                /// </remarks>
                public DateTime? CheckIsRollNecessary()
                {
                    // check for size roll, if enabled.
                    if ((this.owner.rollSizeInBytes > 0) && (this.managedWriter != null)
                        && (this.managedWriter.Tally > this.owner.rollSizeInBytes)) return this.dateTimeProvider.CurrentDateTime;

                    // check for date roll, if enabled.
                    var currentDateTime = this.dateTimeProvider.CurrentDateTime;
                    if ((this.owner.rollInterval != RollInterval.None) && (this.NextRollDateTime != null)
                        && (currentDateTime.CompareTo(this.NextRollDateTime.Value) >= 0)) return currentDateTime;

                    // no roll is necessary, return a null roll date
                    return null;
                }

                /// <summary>
                ///     Gets the file name to use for archiving the file.
                /// </summary>
                /// <param name="actualFileName">The actual file name.</param>
                /// <param name="currentDateTime">The current date and time.</param>
                /// <returns>The new file name.</returns>
                public string ComputeArchiveFileName(string actualFileName, DateTime currentDateTime)
                {
                    var directory = Path.GetDirectoryName(actualFileName);
                    if (!string.IsNullOrWhiteSpace(this.owner.archivedFolderPattern))
                    {
                        var rollingDirectory = Path.Combine(
                            directory,
                            DateTime.Now.ToString(this.owner.archivedFolderPattern));
                        try
                        {
                            if (!Directory.Exists(rollingDirectory)) Directory.CreateDirectory(rollingDirectory);
                            directory = rollingDirectory;
                        }
                        catch (Exception)
                        {
                            //Debug.WriteLine(ex);
                        }
                    }
                    var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(actualFileName);
                    var extension = Path.GetExtension(actualFileName);

                    var fileNameBuilder = new StringBuilder(fileNameWithoutExtension);
                    if (!string.IsNullOrEmpty(this.owner.timeStampPattern))
                    {
                        fileNameBuilder.Append('.');
                        fileNameBuilder.Append(
                            currentDateTime.ToString(this.owner.timeStampPattern, CultureInfo.InvariantCulture));
                    }

                    if (this.owner.rollFileExistsBehavior == RollFileExistsBehavior.Increment)
                    {
                        // look for max sequence for date
                        var newSequence = FindMaxSequenceNumber(directory, fileNameBuilder.ToString(), extension) + 1;
                        fileNameBuilder.Append('.');
                        fileNameBuilder.Append(newSequence.ToString(CultureInfo.InvariantCulture));
                    }

                    fileNameBuilder.Append(extension);

                    return Path.Combine(directory, fileNameBuilder.ToString());
                }

                /// <summary>
                ///     Finds the max sequence number for a log file.
                /// </summary>
                /// <param name="directoryName">The directory to scan.</param>
                /// <param name="fileName">The file name.</param>
                /// <param name="extension">The extension to use.</param>
                /// <returns>The next sequence number.</returns>
                public static int FindMaxSequenceNumber(string directoryName, string fileName, string extension)
                {
                    var existingFiles = Directory.GetFiles(directoryName, string.Format("{0}*{1}", fileName, extension));

                    var maxSequence = 0;
                    var regex = new Regex(string.Format(@"{0}\.(?<sequence>\d+){1}$", fileName, extension));
                    for (var i = 0; i < existingFiles.Length; i++)
                    {
                        var sequenceMatch = regex.Match(existingFiles[i]);
                        if (sequenceMatch.Success)
                        {
                            var currentSequence = 0;

                            var sequenceInFile = sequenceMatch.Groups["sequence"].Value;
                            if (!int.TryParse(sequenceInFile, out currentSequence)) continue; // very unlikely

                            if (currentSequence > maxSequence) maxSequence = currentSequence;
                        }
                    }

                    return maxSequence;
                }

                private static Encoding GetEncodingWithFallback()
                {
                    var encoding = (Encoding)new UTF8Encoding(false).Clone();
                    encoding.EncoderFallback = EncoderFallback.ReplacementFallback;
                    encoding.DecoderFallback = DecoderFallback.ReplacementFallback;
                    return encoding;
                }

                /// <summary>
                ///     Perform the roll for the next date.
                /// </summary>
                /// <param name="rollDateTime">The roll date.</param>
                public void PerformRoll(DateTime rollDateTime)
                {
                    var actualFileName = ((FileStream)((StreamWriter)this.owner.Writer).BaseStream).Name;

                    if ((this.owner.rollFileExistsBehavior == RollFileExistsBehavior.Overwrite)
                        && string.IsNullOrEmpty(this.owner.timeStampPattern))
                    {
                        // no roll will be actually performed: no timestamp pattern is available, and 
                        // the roll behavior is overwrite, so the original file will be truncated
                        this.owner.Writer.Close();
                        File.WriteAllText(actualFileName, string.Empty);
                    }
                    else
                    {
                        // calculate archive name
                        var archiveFileName = this.ComputeArchiveFileName(actualFileName, rollDateTime);
                        // close file
                        this.owner.Writer.Close();
                        // move file
                        this.SafeMove(actualFileName, archiveFileName, rollDateTime);
                        // purge if necessary
                        this.PurgeArchivedFiles(archiveFileName);
                    }

                    // update writer - let TWTL open the file as needed to keep consistency
                    this.owner.Writer = null;
                    this.managedWriter = null;
                    this.NextRollDateTime = null;
                    this.UpdateRollingInformationIfNecessary();
                }

                /// <summary>
                ///     Rolls the file if necessary.
                /// </summary>
                public void RollIfNecessary()
                {
                    if (!this.performsRolling) return;

                    if (!this.UpdateRollingInformationIfNecessary()) return;

                    DateTime? rollDateTime;
                    if ((rollDateTime = this.CheckIsRollNecessary()) != null) this.PerformRoll(rollDateTime.Value);
                }

                private void SafeMove(string actualFileName, string archiveFileName, DateTime currentDateTime)
                {
                    try
                    {
                        if (File.Exists(archiveFileName)) File.Delete(archiveFileName);
                        // take care of tunneling issues http://support.microsoft.com/kb/172190
                        File.SetCreationTime(actualFileName, currentDateTime);
                        File.Move(actualFileName, archiveFileName);
                    }
                    catch (IOException)
                    {
                        // catch errors and attempt move to a new file with a GUID
                        archiveFileName = archiveFileName + Guid.NewGuid();

                        try
                        {
                            File.Move(actualFileName, archiveFileName);
                        }
                        catch (IOException)
                        {
                        }
                    }
                }

                private void PurgeArchivedFiles(string archiveFileName)
                {
                    if (this.owner.maxArchivedFiles > 0)
                    {
                        var directoryName = Path.GetDirectoryName(archiveFileName);
                        var fileName = Path.GetFileName(archiveFileName);

                        new RollingFlatFilePurger(directoryName, fileName, this.owner.maxArchivedFiles).Purge();
                    }
                }

                /// <summary>
                ///     Updates bookeeping information necessary for rolling, as required by the specified
                ///     rolling configuration.
                /// </summary>
                /// <returns>true if update was successful, false if an error occurred.</returns>
                public bool UpdateRollingInformationIfNecessary()
                {
                    StreamWriter currentWriter = null;

                    // replace writer with the tally keeping version if necessary for size rolling
                    if ((this.owner.rollSizeInBytes > 0) && (this.managedWriter == null))
                    {
                        currentWriter = this.owner.Writer as StreamWriter;
                        if (currentWriter == null) return false;
                        var actualFileName = ((FileStream)currentWriter.BaseStream).Name;

                        currentWriter.Close();

                        FileStream fileStream = null;
                        try
                        {
                            fileStream = File.Open(actualFileName, FileMode.Append, FileAccess.Write, FileShare.Read);
                            this.managedWriter = new TallyKeepingFileStreamWriter(fileStream, GetEncodingWithFallback());
                        }
                        catch (Exception)
                        {
                            // there's a slight chance of error here - abort if this occurs and just let TWTL handle it without attempting to roll
                            return false;
                        }

                        this.owner.Writer = this.managedWriter;
                    }

                    // compute the next roll date if necessary
                    if ((this.owner.rollInterval != RollInterval.None) && (this.NextRollDateTime == null))
                        try
                        {
                            // casting should be safe at this point - only file stream writers can be the writers for the owner trace listener.
                            // it should also happen rarely
                            this.NextRollDateTime =
                                this.CalculateNextRollDate(
                                    File.GetCreationTime(
                                        ((FileStream)((StreamWriter)this.owner.Writer).BaseStream).Name));
                        }
                        catch (Exception)
                        {
                            this.NextRollDateTime = DateTime.MaxValue;
                                // disable rolling if not date could be retrieved.

                            // there's a slight chance of error here - abort if this occurs and just let TWTL handle it without attempting to roll
                            return false;
                        }

                    return true;
                }
            }

            /// <summary>
            ///     Represents a file stream writer that keeps a tally of the length of the file.
            /// </summary>
            public sealed class TallyKeepingFileStreamWriter : StreamWriter
            {
                /// <summary>
                ///     Initialize a new instance of the <see cref="TallyKeepingFileStreamWriter" /> class with a <see cref="FileStream" />
                ///     .
                /// </summary>
                /// <param name="stream">The <see cref="FileStream" /> to write to.</param>
                public TallyKeepingFileStreamWriter(FileStream stream)
                    : base(stream)
                {
                    this.Tally = stream.Length;
                }

                /// <summary>
                ///     Initialize a new instance of the <see cref="TallyKeepingFileStreamWriter" /> class with a <see cref="FileStream" />
                ///     .
                /// </summary>
                /// <param name="stream">The <see cref="FileStream" /> to write to.</param>
                /// <param name="encoding">The <see cref="Encoding" /> to use.</param>
                public TallyKeepingFileStreamWriter(FileStream stream, Encoding encoding)
                    : base(stream, encoding)
                {
                    this.Tally = stream.Length;
                }

                /// <summary>
                ///     Gets the tally of the length of the string.
                /// </summary>
                /// <value>
                ///     The tally of the length of the string.
                /// </value>
                public long Tally { get; private set; }

                /// <summary>
                ///     Writes a character to the stream.
                /// </summary>
                /// <param name="value">The character to write to the text stream. </param>
                /// <exception cref="T:System.ObjectDisposedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and current writer is closed.
                /// </exception>
                /// <exception cref="T:System.NotSupportedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and the contents of the buffer cannot be written to the
                ///     underlying fixed size stream because the <see cref="T:System.IO.StreamWriter"></see> is at the end the stream.
                /// </exception>
                /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
                /// <filterpriority>1</filterpriority>
                public override void Write(char value)
                {
                    base.Write(value);
                    this.Tally += this.Encoding.GetByteCount(new[] { value });
                }

                /// <summary>
                ///     Writes a character array to the stream.
                /// </summary>
                /// <param name="buffer">A character array containing the data to write. If buffer is null, nothing is written. </param>
                /// <exception cref="T:System.ObjectDisposedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and current writer is closed.
                /// </exception>
                /// <exception cref="T:System.NotSupportedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and the contents of the buffer cannot be written to the
                ///     underlying fixed size stream because the <see cref="T:System.IO.StreamWriter"></see> is at the end the stream.
                /// </exception>
                /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
                /// <filterpriority>1</filterpriority>
                public override void Write(char[] buffer)
                {
                    base.Write(buffer);
                    this.Tally += this.Encoding.GetByteCount(buffer);
                }

                /// <summary>
                ///     Writes a subarray of characters to the stream.
                /// </summary>
                /// <param name="count">The number of characters to read from buffer. </param>
                /// <param name="buffer">A character array containing the data to write. </param>
                /// <param name="index">The index into buffer at which to begin writing. </param>
                /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
                /// <exception cref="T:System.ObjectDisposedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and current writer is closed.
                /// </exception>
                /// <exception cref="T:System.NotSupportedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and the contents of the buffer cannot be written to the
                ///     underlying fixed size stream because the <see cref="T:System.IO.StreamWriter"></see> is at the end the stream.
                /// </exception>
                /// <exception cref="T:System.ArgumentOutOfRangeException">index or count is negative. </exception>
                /// <exception cref="T:System.ArgumentException">The buffer length minus index is less than count. </exception>
                /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
                /// <filterpriority>1</filterpriority>
                public override void Write(char[] buffer, int index, int count)
                {
                    base.Write(buffer, index, count);
                    this.Tally += this.Encoding.GetByteCount(buffer, index, count);
                }

                /// <summary>
                ///     Writes a string to the stream.
                /// </summary>
                /// <param name="value">The string to write to the stream. If value is null, nothing is written. </param>
                /// <exception cref="T:System.ObjectDisposedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and current writer is closed.
                /// </exception>
                /// <exception cref="T:System.NotSupportedException">
                ///     <see cref="P:System.IO.StreamWriter.AutoFlush"></see> is true or the
                ///     <see cref="T:System.IO.StreamWriter"></see> buffer is full, and the contents of the buffer cannot be written to the
                ///     underlying fixed size stream because the <see cref="T:System.IO.StreamWriter"></see> is at the end the stream.
                /// </exception>
                /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
                /// <filterpriority>1</filterpriority>
                public override void Write(string value)
                {
                    base.Write(value);
                    this.Tally += this.Encoding.GetByteCount(value);
                }
            }
        }

        /// <summary>
        ///     Provides tracing services through a set of <see cref="TraceListener" />s.
        /// </summary>
        public class LogSource : IDisposable
        {
            /// <summary>
            ///     Default Auto Flush property for the LogSource instance.
            /// </summary>
            public const bool DefaultAutoFlushProperty = true;

            public LogSource()
            {
                var listener = new RollingFlatFileTraceListener(
                                   "App_Data/trace.log",
                                   string.Empty,
                                   string.Empty,
                                   1024,
                                   "yyyyMMddHHmmssfff",
                                   "'archived'yyyyMMdd",
                                   RollFileExistsBehavior.Increment,
                                   RollInterval.Day);

                this.Listeners = new TraceListener[] { listener };
            }

            /// <summary>
            ///     Initializes a new instance of the <see cref="LogSource" /> class with a name, a collection of
            ///     <see cref="TraceListener" />s, a level and the auto flush.
            /// </summary>
            /// <param name="name">The name for the instance.</param>
            /// <param name="traceListeners">The collection of <see cref="TraceListener" />s.</param>
            /// <param name="level">The <see cref="SourceLevels" /> value.</param>
            /// <param name="autoFlush">If Flush should be called on the Listeners after every write.</param>
            public LogSource(TraceListener[] traceListeners, bool autoFlush)
            {
                this.Listeners = traceListeners;

                this.AutoFlush = autoFlush;
            }

            /// <summary>
            ///     Gets the collection of trace listeners for the <see cref="LogSource" /> instance.
            /// </summary>
            /// <value>The listeners.</value>
            public TraceListener[] Listeners { get; }

            /// <summary>
            ///     Gets or sets the <see cref="AutoFlush" /> values for the <see cref="LogSource" /> instance.
            /// </summary>
            public bool AutoFlush { get; set; } = DefaultAutoFlushProperty;

            /// <summary>
            ///     Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            /// </summary>
            public void Dispose()
            {
                this.Dispose(true);
                GC.SuppressFinalize(this);
            }

            public void WriteLine(object logEntry)
            {
                foreach (var item in this.Listeners)
                {
                    var listener = item;
                    try
                    {
                        if (!listener.IsThreadSafe) Monitor.Enter(listener);
                        listener.WriteLine(logEntry);
                        if (this.AutoFlush) listener.Flush();
                    }
                    finally
                    {
                        if (!listener.IsThreadSafe) Monitor.Exit(listener);
                    }
                }
            }

            /// <summary>
            ///     Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            /// </summary>
            /// <param name="disposing">
            ///     <see langword="true" /> if the method is being called from the <see cref="Dispose()" /> method.
            ///     <see langword="false" /> if it is being called from within the object finalizer.
            /// </param>
            protected virtual void Dispose(bool disposing)
            {
                if (disposing) foreach (var listener in this.Listeners) listener.Dispose();
            }

            /// <summary>
            ///     Releases resources for the <see cref="LogSource" /> instance before garbage collection.
            /// </summary>
            ~LogSource()
            {
                this.Dispose(false);
            }
        }

        /// <summary>
        ///     Class to write data to a csv file
        /// </summary>
        public sealed class CsvWriter : IDisposable
        {
            #region Members

            private StreamWriter _streamWriter;

            #endregion Members

            #region Properties

            /// <summary>
            ///     Gets or sets whether carriage returns and line feeds should be removed from
            ///     field values, the default is true
            /// </summary>
            public bool ReplaceCarriageReturnsAndLineFeedsFromFieldValues { get; set; } = true;

            /// <summary>
            ///     Gets or sets what the carriage return and line feed replacement characters should be
            /// </summary>
            public string CarriageReturnAndLineFeedReplacement { get; set; } = ",";

            #endregion Properties

            #region Methods

            #region CsvFile write methods

            /// <summary>
            ///     Writes csv content to a file
            /// </summary>
            /// <param name="csvFile">CsvFile</param>
            /// <param name="filePath">File path</param>
            public void WriteCsv(CsvFile csvFile, string filePath)
            {
                this.WriteCsv(csvFile, filePath, null);
            }

            /// <summary>
            ///     Writes csv content to a file
            /// </summary>
            /// <param name="csvFile">CsvFile</param>
            /// <param name="filePath">File path</param>
            /// <param name="encoding">Encoding</param>
            public void WriteCsv(CsvFile csvFile, string filePath, Encoding encoding)
            {
                if (File.Exists(filePath)) File.Delete(filePath);

                using (var writer = new StreamWriter(filePath, false, encoding ?? Encoding.Default))
                {
                    this.WriteToStream(csvFile, writer);
                    writer.Flush();
                    writer.Close();
                }
            }

            /// <summary>
            ///     Writes csv content to a stream
            /// </summary>
            /// <param name="csvFile">CsvFile</param>
            /// <param name="stream">Stream</param>
            public void WriteCsv(CsvFile csvFile, Stream stream)
            {
                this.WriteCsv(csvFile, stream, null);
            }

            /// <summary>
            ///     Writes csv content to a stream
            /// </summary>
            /// <param name="csvFile">CsvFile</param>
            /// <param name="stream">Stream</param>
            /// <param name="encoding">Encoding</param>
            public void WriteCsv(CsvFile csvFile, Stream stream, Encoding encoding)
            {
                stream.Position = 0;
                this._streamWriter = new StreamWriter(stream, encoding ?? Encoding.Default);
                this.WriteToStream(csvFile, this._streamWriter);
                this._streamWriter.Flush();
                stream.Position = 0;
            }

            /// <summary>
            ///     Writes csv content to a string
            /// </summary>
            /// <param name="csvFile">CsvFile</param>
            /// <param name="encoding">Encoding</param>
            /// <returns>Csv content in a string</returns>
            public string WriteCsv(CsvFile csvFile, Encoding encoding)
            {
                var content = string.Empty;

                using (var memoryStream = new MemoryStream())
                {
                    using (var writer = new StreamWriter(memoryStream, encoding ?? Encoding.Default))
                    {
                        this.WriteToStream(csvFile, writer);
                        writer.Flush();
                        memoryStream.Position = 0;

                        using (var reader = new StreamReader(memoryStream, encoding ?? Encoding.Default))
                        {
                            content = reader.ReadToEnd();
                            writer.Close();
                            reader.Close();
                            memoryStream.Close();
                        }
                    }
                }

                return content;
            }

            #endregion CsvFile write methods

            #region DataTable write methods

            /// <summary>
            ///     Writes a DataTable to a file
            /// </summary>
            /// <param name="dataTable">DataTable</param>
            /// <param name="filePath">File path</param>
            public void WriteCsv(DataTable dataTable, string filePath)
            {
                this.WriteCsv(dataTable, filePath, null);
            }

            /// <summary>
            ///     Writes a DataTable to a file
            /// </summary>
            /// <param name="dataTable">DataTable</param>
            /// <param name="filePath">File path</param>
            /// <param name="encoding">Encoding</param>
            public void WriteCsv(DataTable dataTable, string filePath, Encoding encoding)
            {
                if (File.Exists(filePath)) File.Delete(filePath);

                using (var writer = new StreamWriter(filePath, false, encoding ?? Encoding.Default))
                {
                    this.WriteToStream(dataTable, writer);
                    writer.Flush();
                    writer.Close();
                }
            }

            /// <summary>
            ///     Writes a DataTable to a stream
            /// </summary>
            /// <param name="dataTable">DataTable</param>
            /// <param name="stream">Stream</param>
            public void WriteCsv(DataTable dataTable, Stream stream)
            {
                this.WriteCsv(dataTable, stream, null);
            }

            /// <summary>
            ///     Writes a DataTable to a stream
            /// </summary>
            /// <param name="dataTable">DataTable</param>
            /// <param name="stream">Stream</param>
            /// <param name="encoding">Encoding</param>
            public void WriteCsv(DataTable dataTable, Stream stream, Encoding encoding)
            {
                stream.Position = 0;
                this._streamWriter = new StreamWriter(stream, encoding ?? Encoding.Default);
                this.WriteToStream(dataTable, this._streamWriter);
                this._streamWriter.Flush();
                stream.Position = 0;
            }

            /// <summary>
            ///     Writes the DataTable to a string
            /// </summary>
            /// <param name="dataTable">DataTable</param>
            /// <param name="encoding">Encoding</param>
            /// <returns>Csv content in a string</returns>
            public string WriteCsv(DataTable dataTable, Encoding encoding)
            {
                var content = string.Empty;

                using (var memoryStream = new MemoryStream())
                {
                    using (var writer = new StreamWriter(memoryStream, encoding ?? Encoding.Default))
                    {
                        this.WriteToStream(dataTable, writer);
                        writer.Flush();
                        memoryStream.Position = 0;

                        using (var reader = new StreamReader(memoryStream, encoding ?? Encoding.Default))
                        {
                            content = reader.ReadToEnd();
                            writer.Close();
                            reader.Close();
                            memoryStream.Close();
                        }
                    }
                }

                return content;
            }

            #endregion DataTable write methods

            /// <summary>
            ///     Writes the Csv File
            /// </summary>
            /// <param name="csvFile">CsvFile</param>
            /// <param name="writer">TextWriter</param>
            private void WriteToStream(CsvFile csvFile, TextWriter writer)
            {
                if (csvFile.Headers.Count > 0) this.WriteRecord(csvFile.Headers, writer);

                csvFile.Records.ForEach(record => this.WriteRecord(record.Fields, writer));
            }

            /// <summary>
            ///     Writes the Csv File
            /// </summary>
            /// <param name="dataTable">DataTable</param>
            /// <param name="writer">TextWriter</param>
            private void WriteToStream(DataTable dataTable, TextWriter writer)
            {
                var fields = (from DataColumn column in dataTable.Columns select column.ColumnName).ToList();
                this.WriteRecord(fields, writer);

                foreach (DataRow row in dataTable.Rows)
                {
                    fields.Clear();
                    fields.AddRange(row.ItemArray.Select(o => o.ToString()));
                    this.WriteRecord(fields, writer);
                }
            }

            /// <summary>
            ///     Writes the record to the underlying stream
            /// </summary>
            /// <param name="fields">Fields</param>
            /// <param name="writer">TextWriter</param>
            private void WriteRecord(IList<string> fields, TextWriter writer)
            {
                for (var i = 0; i < fields.Count; i++)
                {
                    var quotesRequired = fields[i].Contains(",");
                    var escapeQuotes = fields[i].Contains("\"");
                    var fieldValue = escapeQuotes ? fields[i].Replace("\"", "\"\"") : fields[i];

                    if (this.ReplaceCarriageReturnsAndLineFeedsFromFieldValues
                        && (fieldValue.Contains("\r") || fieldValue.Contains("\n")))
                    {
                        quotesRequired = true;
                        fieldValue = fieldValue.Replace("\r\n", this.CarriageReturnAndLineFeedReplacement);
                        fieldValue = fieldValue.Replace("\r", this.CarriageReturnAndLineFeedReplacement);
                        fieldValue = fieldValue.Replace("\n", this.CarriageReturnAndLineFeedReplacement);
                    }

                    writer.Write(
                        "{0}{1}{0}{2}",
                        quotesRequired || escapeQuotes ? "\"" : string.Empty,
                        fieldValue,
                        i < fields.Count - 1 ? "," : string.Empty);
                }

                writer.WriteLine();
            }

            /// <summary>
            ///     Disposes of all unmanaged resources
            /// </summary>
            public void Dispose()
            {
                if (this._streamWriter == null) return;

                this._streamWriter.Close();
                this._streamWriter.Dispose();
            }

            #endregion Methods
        }

        /// <summary>
        ///     Class to read csv content from various sources
        /// </summary>
        public sealed class CsvReader : IDisposable
        {
            #region Enums

            /// <summary>
            ///     Type enum
            /// </summary>
            private enum Type
            {
                File,

                Stream,

                String
            }

            #endregion Enums

            #region Members

            private FileStream _fileStream;

            private Stream _stream;

            private StreamReader _streamReader;

            private StreamWriter _streamWriter;

            private Stream _memoryStream;

            private Encoding _encoding;

            private readonly StringBuilder _columnBuilder = new StringBuilder(100);

            private readonly Type _type = Type.File;

            #endregion Members

            #region Properties

            /// <summary>
            ///     Gets or sets whether column values should be trimmed
            /// </summary>
            public bool TrimColumns { get; set; }

            /// <summary>
            ///     Gets or sets whether the csv file has a header row
            /// </summary>
            public bool HasHeaderRow { get; set; }

            /// <summary>
            ///     Returns a collection of fields or null if no record has been read
            /// </summary>
            public List<string> Fields { get; private set; }

            /// <summary>
            ///     Gets the field count or returns null if no fields have been read
            /// </summary>
            public int? FieldCount
            {
                get
                {
                    return this.Fields != null ? this.Fields.Count : (int?)null;
                }
            }

            #endregion Properties

            #region Constructors

            /// <summary>
            ///     Initialises the reader to work from a file
            /// </summary>
            /// <param name="filePath">File path</param>
            public CsvReader(string filePath)
            {
                this._type = Type.File;
                this.Initialise(filePath, Encoding.Default);
            }

            /// <summary>
            ///     Initialises the reader to work from a file
            /// </summary>
            /// <param name="filePath">File path</param>
            /// <param name="encoding">Encoding</param>
            public CsvReader(string filePath, Encoding encoding)
            {
                this._type = Type.File;
                this.Initialise(filePath, encoding);
            }

            /// <summary>
            ///     Initialises the reader to work from an existing stream
            /// </summary>
            /// <param name="stream">Stream</param>
            public CsvReader(Stream stream)
            {
                this._type = Type.Stream;
                this.Initialise(stream, Encoding.Default);
            }

            /// <summary>
            ///     Initialises the reader to work from an existing stream
            /// </summary>
            /// <param name="stream">Stream</param>
            /// <param name="encoding">Encoding</param>
            public CsvReader(Stream stream, Encoding encoding)
            {
                this._type = Type.Stream;
                this.Initialise(stream, encoding);
            }

            /// <summary>
            ///     Initialises the reader to work from a csv string
            /// </summary>
            /// <param name="encoding"></param>
            /// <param name="csvContent"></param>
            public CsvReader(Encoding encoding, string csvContent)
            {
                this._type = Type.String;
                this.Initialise(encoding, csvContent);
            }

            #endregion Constructors

            #region Methods

            /// <summary>
            ///     Initialises the class to use a file
            /// </summary>
            /// <param name="filePath"></param>
            /// <param name="encoding"></param>
            private void Initialise(string filePath, Encoding encoding)
            {
                if (!File.Exists(filePath)) throw new FileNotFoundException(string.Format("The file '{0}' does not exist.", filePath));

                this._fileStream = File.OpenRead(filePath);
                this.Initialise(this._fileStream, encoding);
            }

            /// <summary>
            ///     Initialises the class to use a stream
            /// </summary>
            /// <param name="stream"></param>
            /// <param name="encoding"></param>
            private void Initialise(Stream stream, Encoding encoding)
            {
                if (stream == null) throw new ArgumentNullException("The supplied stream is null.");

                this._stream = stream;
                this._stream.Position = 0;
                this._encoding = encoding ?? Encoding.Default;
                this._streamReader = new StreamReader(this._stream, this._encoding);
            }

            /// <summary>
            ///     Initialies the class to use a string
            /// </summary>
            /// <param name="encoding"></param>
            /// <param name="csvContent"></param>
            private void Initialise(Encoding encoding, string csvContent)
            {
                if (csvContent == null) throw new ArgumentNullException("The supplied csvContent is null.");

                this._encoding = encoding ?? Encoding.Default;

                this._memoryStream = new MemoryStream(csvContent.Length);
                this._streamWriter = new StreamWriter(this._memoryStream);
                this._streamWriter.Write(csvContent);
                this._streamWriter.Flush();
                this.Initialise(this._memoryStream, encoding);
            }

            /// <summary>
            ///     Reads the next record
            /// </summary>
            /// <returns>True if a record was successfuly read, otherwise false</returns>
            public bool ReadNextRecord()
            {
                this.Fields = null;
                var line = this._streamReader.ReadLine();

                if (line == null) return false;

                this.ParseLine(line);
                return true;
            }

            /// <summary>
            ///     Reads a csv file format into a data table.  This method
            ///     will always assume that the table has a header row as this will be used
            ///     to determine the columns.
            /// </summary>
            /// <returns></returns>
            public DataTable ReadIntoDataTable()
            {
                return this.ReadIntoDataTable(new System.Type[] { });
            }

            /// <summary>
            ///     Reads a csv file format into a data table.  This method
            ///     will always assume that the table has a header row as this will be used
            ///     to determine the columns.
            /// </summary>
            /// <param name="columnTypes">Array of column types</param>
            /// <returns></returns>
            public DataTable ReadIntoDataTable(System.Type[] columnTypes)
            {
                var dataTable = new DataTable();
                var addedHeader = false;
                this._stream.Position = 0;

                while (this.ReadNextRecord())
                {
                    if (!addedHeader)
                    {
                        for (var i = 0; i < this.Fields.Count; i++)
                            dataTable.Columns.Add(
                                this.Fields[i],
                                columnTypes.Length > 0 ? columnTypes[i] : typeof(string));

                        addedHeader = true;
                        continue;
                    }

                    var row = dataTable.NewRow();

                    for (var i = 0; i < this.Fields.Count; i++) row[i] = this.Fields[i];

                    dataTable.Rows.Add(row);
                }

                return dataTable;
            }

            /// <summary>
            ///     Parses a csv line
            /// </summary>
            /// <param name="line">Line</param>
            private void ParseLine(string line)
            {
                this.Fields = new List<string>();
                var inColumn = false;
                var inQuotes = false;
                //_columnBuilder.Remove(0, _columnBuilder.Length);
                this._columnBuilder.Length = 0;
                // Iterate through every character in the line
                for (var i = 0; i < line.Length; i++)
                {
                    var character = line[i];

                    // If we are not currently inside a column
                    if (!inColumn)
                    {
                        // If the current character is a double quote then the column value is contained within
                        // double quotes, otherwise append the next character
                        if (character == '"') inQuotes = true;
                        else this._columnBuilder.Append(character);

                        inColumn = true;
                        continue;
                    }

                    // If we are in between double quotes
                    if (inQuotes)
                    {
                        // If the current character is a double quote and the next character is a comma or we are at the end of the line
                        // we are now no longer within the column.
                        // Otherwise increment the loop counter as we are looking at an escaped double quote e.g. "" within a column
                        if ((character == '"')
                            && (((line.Length > i + 1) && (line[i + 1] == ',')) || (i + 1 == line.Length)))
                        {
                            inQuotes = false;
                            inColumn = false;
                            i++;
                        }
                        else if ((character == '"') && (line.Length > i + 1) && (line[i + 1] == '"')) i++;
                    }
                    else if (character == ',') inColumn = false;

                    // If we are no longer in the column clear the builder and add the columns to the list
                    if (!inColumn)
                    {
                        this.Fields.Add(
                            this.TrimColumns ? this._columnBuilder.ToString().Trim() : this._columnBuilder.ToString());
                        //_columnBuilder.Remove(0, _columnBuilder.Length);
                        this._columnBuilder.Length = 0;
                    }
                    else // append the current column
                        this._columnBuilder.Append(character);
                }

                // If we are still inside a column add a new one
                if (inColumn)
                    this.Fields.Add(
                        this.TrimColumns ? this._columnBuilder.ToString().Trim() : this._columnBuilder.ToString());
            }

            /// <summary>
            ///     Disposes of all unmanaged resources
            /// </summary>
            public void Dispose()
            {
                if (this._streamReader != null)
                {
                    this._streamReader.Close();
                    this._streamReader.Dispose();
                }

                if (this._streamWriter != null)
                {
                    this._streamWriter.Close();
                    this._streamWriter.Dispose();
                }

                if (this._memoryStream != null)
                {
                    this._memoryStream.Close();
                    this._memoryStream.Dispose();
                }

                if (this._fileStream != null)
                {
                    this._fileStream.Close();
                    this._fileStream.Dispose();
                }

                if (((this._type == Type.String) || (this._type == Type.File)) && (this._stream != null))
                {
                    this._stream.Close();
                    this._stream.Dispose();
                }
            }

            #endregion Methods
        }

        /// <summary>
        ///     Class to hold csv data
        /// </summary>
        [Serializable]
        public sealed class CsvFile
        {
            #region Properties

            /// <summary>
            ///     Gets the file headers
            /// </summary>
            public readonly List<string> Headers = new List<string>();

            /// <summary>
            ///     Gets the records in the file
            /// </summary>
            public readonly CsvRecords Records = new CsvRecords();

            /// <summary>
            ///     Gets the header count
            /// </summary>
            public int HeaderCount
            {
                get
                {
                    return this.Headers.Count;
                }
            }

            /// <summary>
            ///     Gets the record count
            /// </summary>
            public int RecordCount
            {
                get
                {
                    return this.Records.Count;
                }
            }

            #endregion Properties

            #region Indexers

            /// <summary>
            ///     Gets a record at the specified index
            /// </summary>
            /// <param name="recordIndex">Record index</param>
            /// <returns>CsvRecord</returns>
            public CsvRecord this[int recordIndex]
            {
                get
                {
                    if (recordIndex > this.Records.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format("There is no record at index {0}.", recordIndex));

                    return this.Records[recordIndex];
                }
            }

            /// <summary>
            ///     Gets the field value at the specified record and field index
            /// </summary>
            /// <param name="recordIndex">Record index</param>
            /// <param name="fieldIndex">Field index</param>
            /// <returns></returns>
            public string this[int recordIndex, int fieldIndex]
            {
                get
                {
                    if (recordIndex > this.Records.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format("There is no record at index {0}.", recordIndex));

                    var record = this.Records[recordIndex];
                    if (fieldIndex > record.Fields.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format(
                                      "There is no field at index {0} in record {1}.",
                                      fieldIndex,
                                      recordIndex));

                    return record.Fields[fieldIndex];
                }
                set
                {
                    if (recordIndex > this.Records.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format("There is no record at index {0}.", recordIndex));

                    var record = this.Records[recordIndex];

                    if (fieldIndex > record.Fields.Count - 1) throw new IndexOutOfRangeException(string.Format("There is no field at index {0}.", fieldIndex));

                    record.Fields[fieldIndex] = value;
                }
            }

            /// <summary>
            ///     Gets the field value at the specified record index for the supplied field name
            /// </summary>
            /// <param name="recordIndex">Record index</param>
            /// <param name="fieldName">Field name</param>
            /// <returns></returns>
            public string this[int recordIndex, string fieldName]
            {
                get
                {
                    if (recordIndex > this.Records.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format("There is no record at index {0}.", recordIndex));

                    var record = this.Records[recordIndex];

                    var fieldIndex = -1;

                    for (var i = 0; i < this.Headers.Count; i++)
                    {
                        if (string.Compare(this.Headers[i], fieldName) != 0) continue;

                        fieldIndex = i;
                        break;
                    }

                    if (fieldIndex == -1)
                        throw new ArgumentException(
                                  string.Format("There is no field header with the name '{0}'", fieldName));

                    if (fieldIndex > record.Fields.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format(
                                      "There is no field at index {0} in record {1}.",
                                      fieldIndex,
                                      recordIndex));

                    return record.Fields[fieldIndex];
                }
                set
                {
                    if (recordIndex > this.Records.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format("There is no record at index {0}.", recordIndex));

                    var record = this.Records[recordIndex];

                    var fieldIndex = -1;

                    for (var i = 0; i < this.Headers.Count; i++)
                    {
                        if (string.Compare(this.Headers[i], fieldName) != 0) continue;

                        fieldIndex = i;
                        break;
                    }

                    if (fieldIndex == -1)
                        throw new ArgumentException(
                                  string.Format("There is no field header with the name '{0}'", fieldName));

                    if (fieldIndex > record.Fields.Count - 1)
                        throw new IndexOutOfRangeException(
                                  string.Format(
                                      "There is no field at index {0} in record {1}.",
                                      fieldIndex,
                                      recordIndex));

                    record.Fields[fieldIndex] = value;
                }
            }

            #endregion Indexers

            #region Methods

            /// <summary>
            ///     Populates the current instance from the specified file
            /// </summary>
            /// <param name="filePath">File path</param>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            public void Populate(string filePath, bool hasHeaderRow)
            {
                this.Populate(filePath, null, hasHeaderRow, false);
            }

            /// <summary>
            ///     Populates the current instance from the specified file
            /// </summary>
            /// <param name="filePath">File path</param>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            /// <param name="trimColumns">True if column values should be trimmed, otherwise false</param>
            public void Populate(string filePath, bool hasHeaderRow, bool trimColumns)
            {
                this.Populate(filePath, null, hasHeaderRow, trimColumns);
            }

            /// <summary>
            ///     Populates the current instance from the specified file
            /// </summary>
            /// <param name="filePath">File path</param>
            /// <param name="encoding">Encoding</param>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            /// <param name="trimColumns">True if column values should be trimmed, otherwise false</param>
            public void Populate(string filePath, Encoding encoding, bool hasHeaderRow, bool trimColumns)
            {
                using (
                    var reader = new CsvReader(filePath, encoding)
                                     {
                                         HasHeaderRow = hasHeaderRow,
                                         TrimColumns = trimColumns
                                     })
                {
                    this.PopulateCsvFile(reader);
                }
            }

            /// <summary>
            ///     Populates the current instance from a stream
            /// </summary>
            /// <param name="stream">Stream</param>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            public void Populate(Stream stream, bool hasHeaderRow)
            {
                this.Populate(stream, null, hasHeaderRow, false);
            }

            /// <summary>
            ///     Populates the current instance from a stream
            /// </summary>
            /// <param name="stream">Stream</param>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            /// <param name="trimColumns">True if column values should be trimmed, otherwise false</param>
            public void Populate(Stream stream, bool hasHeaderRow, bool trimColumns)
            {
                this.Populate(stream, null, hasHeaderRow, trimColumns);
            }

            /// <summary>
            ///     Populates the current instance from a stream
            /// </summary>
            /// <param name="stream">Stream</param>
            /// <param name="encoding">Encoding</param>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            /// <param name="trimColumns">True if column values should be trimmed, otherwise false</param>
            public void Populate(Stream stream, Encoding encoding, bool hasHeaderRow, bool trimColumns)
            {
                using (
                    var reader = new CsvReader(stream, encoding)
                                     {
                                         HasHeaderRow = hasHeaderRow,
                                         TrimColumns = trimColumns
                                     })
                {
                    this.PopulateCsvFile(reader);
                }
            }

            /// <summary>
            ///     Populates the current instance from a string
            /// </summary>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            /// <param name="csvContent">Csv text</param>
            public void Populate(bool hasHeaderRow, string csvContent)
            {
                this.Populate(hasHeaderRow, csvContent, null, false);
            }

            /// <summary>
            ///     Populates the current instance from a string
            /// </summary>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            /// <param name="csvContent">Csv text</param>
            /// <param name="trimColumns">True if column values should be trimmed, otherwise false</param>
            public void Populate(bool hasHeaderRow, string csvContent, bool trimColumns)
            {
                this.Populate(hasHeaderRow, csvContent, null, trimColumns);
            }

            /// <summary>
            ///     Populates the current instance from a string
            /// </summary>
            /// <param name="hasHeaderRow">True if the file has a header row, otherwise false</param>
            /// <param name="csvContent">Csv text</param>
            /// <param name="encoding">Encoding</param>
            /// <param name="trimColumns">True if column values should be trimmed, otherwise false</param>
            public void Populate(bool hasHeaderRow, string csvContent, Encoding encoding, bool trimColumns)
            {
                using (
                    var reader = new CsvReader(encoding, csvContent)
                                     {
                                         HasHeaderRow = hasHeaderRow,
                                         TrimColumns = trimColumns
                                     })
                {
                    this.PopulateCsvFile(reader);
                }
            }

            /// <summary>
            ///     Populates the current instance using the CsvReader object
            /// </summary>
            /// <param name="reader">CsvReader</param>
            private void PopulateCsvFile(CsvReader reader)
            {
                this.Headers.Clear();
                this.Records.Clear();

                var addedHeader = false;

                while (reader.ReadNextRecord())
                {
                    if (reader.HasHeaderRow && !addedHeader)
                    {
                        reader.Fields.ForEach(field => this.Headers.Add(field));
                        addedHeader = true;
                        continue;
                    }

                    var record = new CsvRecord();
                    reader.Fields.ForEach(field => record.Fields.Add(field));
                    this.Records.Add(record);
                }
            }

            #endregion Methods
        }

        /// <summary>
        ///     Class for a collection of CsvRecord objects
        /// </summary>
        [Serializable]
        public sealed class CsvRecords : List<CsvRecord>
        {
        }

        /// <summary>
        ///     Csv record class
        /// </summary>
        [Serializable]
        public sealed class CsvRecord
        {
            #region Properties

            /// <summary>
            ///     Gets the Fields in the record
            /// </summary>
            public readonly List<string> Fields = new List<string>();

            /// <summary>
            ///     Gets the number of fields in the record
            /// </summary>
            public int FieldCount
            {
                get
                {
                    return this.Fields.Count;
                }
            }

            #endregion Properties
        }
    }
    
}